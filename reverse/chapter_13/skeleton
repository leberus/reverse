(Rough skeleton of loop from 2 to 9 inclusive:)

mov [counter], 2 ; initialization
jmp check
body:
; loop body
; do something here
; use counter variable in local stack
add [counter], 1 ; increment
check:
cmp [counter], 9
jle body



(The increment operation may be represented as 3 instructions in non-optimized code:)

MOV [counter], 2 ; initialization
JMP check
body:
; loop body
; do something here
; use counter variable in local stack
MOV REG, [counter] ; increment
INC REG
MOV [counter], REG
check:
CMP [counter], 9
JLE body




(If the body of the loop is short, a whole register can be dedicated to the counter variable.)

MOV EBX, 2 ; initialization
JMP check
body:
; loop body
; do something here
; use counter in EBX, but do not modify it!
INC EBX ; increment
check:
CMP EBX, 9
JLE body



(Some parts of the loop may be generated by compiler in different order:)

MOV [counter], 2 ; initialization
JMP label_check
label_increment:
ADD [counter], 1 ; increment
label_check:
CMP [counter], 10
JGE exit
; loop body
; do something here
; use counter variable in local stack
JMP label_increment
exit:



(Usually the condition is checked before loop body, but the compiler may rearrange it in a way that the condition is checked after loop body.  This is done when the compiler is sure that the condition is always true on the first iteration, so the body of the loop is to be executed at least once)

MOV REG, 2 ; initialization
body:
; loop body
; do something here
; use counter in REG, but do not modify it!
INC REG ; increment
CMP REG, 10
JL body



(Using the LOOP instruction. This is rare, compilers are not using it. When you see it, itâ€™s a sign that this piece of code is hand-written:)

; count from 10 to 1
MOV ECX, 10
body:
; loop body
; do something here
; use counter in ECX, but do not modify it!
LOOP body



